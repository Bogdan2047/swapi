{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\nvar _globalErrorHandlers = require('./globalErrorHandlers');\nvar _types = require('./types');\nvar _utils = require('./utils');\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\n\n// TODO: investigate why a shorter (event, state) signature results into TS7006 compiler error\nconst eventHandler = (event, state) => {\n  switch (event.name) {\n    case 'include_test_location_in_result':\n      {\n        state.includeTestLocationInResult = true;\n        break;\n      }\n    case 'hook_start':\n      {\n        event.hook.seenDone = false;\n        break;\n      }\n    case 'start_describe_definition':\n      {\n        const {\n          blockName,\n          mode\n        } = event;\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest\n        } = state;\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Cannot nest a describe inside a test. Describe block \"${blockName}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        }\n        const describeBlock = (0, _utils.makeDescribe)(blockName, currentDescribeBlock, mode);\n        currentDescribeBlock.children.push(describeBlock);\n        state.currentDescribeBlock = describeBlock;\n        break;\n      }\n    case 'finish_describe_definition':\n      {\n        const {\n          currentDescribeBlock\n        } = state;\n        (0, _utils.invariant)(currentDescribeBlock, 'currentDescribeBlock must be there');\n        if (!(0, _utils.describeBlockHasTests)(currentDescribeBlock)) {\n          currentDescribeBlock.hooks.forEach(hook => {\n            hook.asyncError.message = `Invalid: ${hook.type}() may not be used in a describe block containing no tests.`;\n            state.unhandledErrors.push(hook.asyncError);\n          });\n        } // pass mode of currentDescribeBlock to tests\n        // but do not when there is already a single test with \"only\" mode\n\n        const shouldPassMode = !(currentDescribeBlock.mode === 'only' && currentDescribeBlock.children.some(child => child.type === 'test' && child.mode === 'only'));\n        if (shouldPassMode) {\n          currentDescribeBlock.children.forEach(child => {\n            if (child.type === 'test' && !child.mode) {\n              child.mode = currentDescribeBlock.mode;\n            }\n          });\n        }\n        if (!state.hasFocusedTests && currentDescribeBlock.mode !== 'skip' && currentDescribeBlock.children.some(child => child.type === 'test' && child.mode === 'only')) {\n          state.hasFocusedTests = true;\n        }\n        if (currentDescribeBlock.parent) {\n          state.currentDescribeBlock = currentDescribeBlock.parent;\n        }\n        break;\n      }\n    case 'add_hook':\n      {\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest,\n          hasStarted\n        } = state;\n        const {\n          asyncError,\n          fn,\n          hookType: type,\n          timeout\n        } = event;\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Hooks cannot be defined inside tests. Hook of type \"${type}\" is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        } else if (hasStarted) {\n          state.unhandledErrors.push(new Error('Cannot add a hook after tests have started running. Hooks must be defined synchronously.'));\n          break;\n        }\n        const parent = currentDescribeBlock;\n        currentDescribeBlock.hooks.push({\n          asyncError,\n          fn,\n          parent,\n          seenDone: false,\n          timeout,\n          type\n        });\n        break;\n      }\n    case 'add_test':\n      {\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest,\n          hasStarted\n        } = state;\n        const {\n          asyncError,\n          fn,\n          mode,\n          testName: name,\n          timeout\n        } = event;\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Tests cannot be nested. Test \"${name}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        } else if (hasStarted) {\n          state.unhandledErrors.push(new Error('Cannot add a test after tests have started running. Tests must be defined synchronously.'));\n          break;\n        }\n        const test = (0, _utils.makeTest)(fn, mode, name, currentDescribeBlock, timeout, asyncError);\n        if (currentDescribeBlock.mode !== 'skip' && test.mode === 'only') {\n          state.hasFocusedTests = true;\n        }\n        currentDescribeBlock.children.push(test);\n        currentDescribeBlock.tests.push(test);\n        break;\n      }\n    case 'hook_failure':\n      {\n        const {\n          test,\n          describeBlock,\n          error,\n          hook\n        } = event;\n        const {\n          asyncError,\n          type\n        } = hook;\n        if (type === 'beforeAll') {\n          (0, _utils.invariant)(describeBlock, 'always present for `*All` hooks');\n          (0, _utils.addErrorToEachTestUnderDescribe)(describeBlock, error, asyncError);\n        } else if (type === 'afterAll') {\n          // Attaching `afterAll` errors to each test makes execution flow\n          // too complicated, so we'll consider them to be global.\n          state.unhandledErrors.push([error, asyncError]);\n        } else {\n          (0, _utils.invariant)(test, 'always present for `*Each` hooks');\n          test.errors.push([error, asyncError]);\n        }\n        break;\n      }\n    case 'test_skip':\n      {\n        event.test.status = 'skip';\n        break;\n      }\n    case 'test_todo':\n      {\n        event.test.status = 'todo';\n        break;\n      }\n    case 'test_done':\n      {\n        event.test.duration = (0, _utils.getTestDuration)(event.test);\n        event.test.status = 'done';\n        state.currentlyRunningTest = null;\n        break;\n      }\n    case 'test_start':\n      {\n        state.currentlyRunningTest = event.test;\n        event.test.startedAt = jestNow();\n        event.test.invocations += 1;\n        break;\n      }\n    case 'test_fn_start':\n      {\n        event.test.seenDone = false;\n        break;\n      }\n    case 'test_fn_failure':\n      {\n        const {\n          error,\n          test: {\n            asyncError\n          }\n        } = event;\n        event.test.errors.push([error, asyncError]);\n        break;\n      }\n    case 'test_retry':\n      {\n        event.test.errors = [];\n        break;\n      }\n    case 'run_start':\n      {\n        state.hasStarted = true;\n        global[_types.TEST_TIMEOUT_SYMBOL] && (state.testTimeout = global[_types.TEST_TIMEOUT_SYMBOL]);\n        break;\n      }\n    case 'run_finish':\n      {\n        break;\n      }\n    case 'setup':\n      {\n        // Uncaught exception handlers should be defined on the parent process\n        // object. If defined on the VM's process object they just no op and let\n        // the parent process crash. It might make sense to return a `dispatch`\n        // function to the parent process and register handlers there instead, but\n        // i'm not sure if this is works. For now i just replicated whatever\n        // jasmine was doing -- dabramov\n        state.parentProcess = event.parentProcess;\n        (0, _utils.invariant)(state.parentProcess);\n        state.originalGlobalErrorHandlers = (0, _globalErrorHandlers.injectGlobalErrorHandlers)(state.parentProcess);\n        if (event.testNamePattern) {\n          state.testNamePattern = new RegExp(event.testNamePattern, 'i');\n        }\n        break;\n      }\n    case 'teardown':\n      {\n        (0, _utils.invariant)(state.originalGlobalErrorHandlers);\n        (0, _utils.invariant)(state.parentProcess);\n        (0, _globalErrorHandlers.restoreGlobalErrorHandlers)(state.parentProcess, state.originalGlobalErrorHandlers);\n        break;\n      }\n    case 'error':\n      {\n        // It's very likely for long-running async tests to throw errors. In this\n        // case we want to catch them and fail the current test. At the same time\n        // there's a possibility that one test sets a long timeout, that will\n        // eventually throw after this test finishes but during some other test\n        // execution, which will result in one test's error failing another test.\n        // In any way, it should be possible to track where the error was thrown\n        // from.\n        state.currentlyRunningTest ? state.currentlyRunningTest.errors.push(event.error) : state.unhandledErrors.push(event.error);\n        break;\n      }\n  }\n};\nvar _default = eventHandler;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_globalErrorHandlers","require","_types","_utils","global","globalThis","self","window","Function","Symbol","jestNow","for","Date","now","eventHandler","event","state","name","includeTestLocationInResult","hook","seenDone","blockName","mode","currentDescribeBlock","currentlyRunningTest","errors","push","Error","describeBlock","makeDescribe","children","invariant","describeBlockHasTests","hooks","forEach","asyncError","message","type","unhandledErrors","shouldPassMode","some","child","hasFocusedTests","parent","hasStarted","fn","hookType","timeout","testName","test","makeTest","tests","error","addErrorToEachTestUnderDescribe","status","duration","getTestDuration","startedAt","invocations","TEST_TIMEOUT_SYMBOL","testTimeout","parentProcess","originalGlobalErrorHandlers","injectGlobalErrorHandlers","testNamePattern","RegExp","restoreGlobalErrorHandlers","_default"],"sources":["/Users/Bohdan/Desktop/swap/node_modules/jest-circus/build/eventHandler.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _globalErrorHandlers = require('./globalErrorHandlers');\n\nvar _types = require('./types');\n\nvar _utils = require('./utils');\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\n\n// TODO: investigate why a shorter (event, state) signature results into TS7006 compiler error\nconst eventHandler = (event, state) => {\n  switch (event.name) {\n    case 'include_test_location_in_result': {\n      state.includeTestLocationInResult = true;\n      break;\n    }\n\n    case 'hook_start': {\n      event.hook.seenDone = false;\n      break;\n    }\n\n    case 'start_describe_definition': {\n      const {blockName, mode} = event;\n      const {currentDescribeBlock, currentlyRunningTest} = state;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Cannot nest a describe inside a test. Describe block \"${blockName}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      }\n\n      const describeBlock = (0, _utils.makeDescribe)(\n        blockName,\n        currentDescribeBlock,\n        mode\n      );\n      currentDescribeBlock.children.push(describeBlock);\n      state.currentDescribeBlock = describeBlock;\n      break;\n    }\n\n    case 'finish_describe_definition': {\n      const {currentDescribeBlock} = state;\n      (0, _utils.invariant)(\n        currentDescribeBlock,\n        'currentDescribeBlock must be there'\n      );\n\n      if (!(0, _utils.describeBlockHasTests)(currentDescribeBlock)) {\n        currentDescribeBlock.hooks.forEach(hook => {\n          hook.asyncError.message = `Invalid: ${hook.type}() may not be used in a describe block containing no tests.`;\n          state.unhandledErrors.push(hook.asyncError);\n        });\n      } // pass mode of currentDescribeBlock to tests\n      // but do not when there is already a single test with \"only\" mode\n\n      const shouldPassMode = !(\n        currentDescribeBlock.mode === 'only' &&\n        currentDescribeBlock.children.some(\n          child => child.type === 'test' && child.mode === 'only'\n        )\n      );\n\n      if (shouldPassMode) {\n        currentDescribeBlock.children.forEach(child => {\n          if (child.type === 'test' && !child.mode) {\n            child.mode = currentDescribeBlock.mode;\n          }\n        });\n      }\n\n      if (\n        !state.hasFocusedTests &&\n        currentDescribeBlock.mode !== 'skip' &&\n        currentDescribeBlock.children.some(\n          child => child.type === 'test' && child.mode === 'only'\n        )\n      ) {\n        state.hasFocusedTests = true;\n      }\n\n      if (currentDescribeBlock.parent) {\n        state.currentDescribeBlock = currentDescribeBlock.parent;\n      }\n\n      break;\n    }\n\n    case 'add_hook': {\n      const {currentDescribeBlock, currentlyRunningTest, hasStarted} = state;\n      const {asyncError, fn, hookType: type, timeout} = event;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Hooks cannot be defined inside tests. Hook of type \"${type}\" is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      } else if (hasStarted) {\n        state.unhandledErrors.push(\n          new Error(\n            'Cannot add a hook after tests have started running. Hooks must be defined synchronously.'\n          )\n        );\n        break;\n      }\n\n      const parent = currentDescribeBlock;\n      currentDescribeBlock.hooks.push({\n        asyncError,\n        fn,\n        parent,\n        seenDone: false,\n        timeout,\n        type\n      });\n      break;\n    }\n\n    case 'add_test': {\n      const {currentDescribeBlock, currentlyRunningTest, hasStarted} = state;\n      const {asyncError, fn, mode, testName: name, timeout} = event;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Tests cannot be nested. Test \"${name}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      } else if (hasStarted) {\n        state.unhandledErrors.push(\n          new Error(\n            'Cannot add a test after tests have started running. Tests must be defined synchronously.'\n          )\n        );\n        break;\n      }\n\n      const test = (0, _utils.makeTest)(\n        fn,\n        mode,\n        name,\n        currentDescribeBlock,\n        timeout,\n        asyncError\n      );\n\n      if (currentDescribeBlock.mode !== 'skip' && test.mode === 'only') {\n        state.hasFocusedTests = true;\n      }\n\n      currentDescribeBlock.children.push(test);\n      currentDescribeBlock.tests.push(test);\n      break;\n    }\n\n    case 'hook_failure': {\n      const {test, describeBlock, error, hook} = event;\n      const {asyncError, type} = hook;\n\n      if (type === 'beforeAll') {\n        (0, _utils.invariant)(describeBlock, 'always present for `*All` hooks');\n        (0, _utils.addErrorToEachTestUnderDescribe)(\n          describeBlock,\n          error,\n          asyncError\n        );\n      } else if (type === 'afterAll') {\n        // Attaching `afterAll` errors to each test makes execution flow\n        // too complicated, so we'll consider them to be global.\n        state.unhandledErrors.push([error, asyncError]);\n      } else {\n        (0, _utils.invariant)(test, 'always present for `*Each` hooks');\n        test.errors.push([error, asyncError]);\n      }\n\n      break;\n    }\n\n    case 'test_skip': {\n      event.test.status = 'skip';\n      break;\n    }\n\n    case 'test_todo': {\n      event.test.status = 'todo';\n      break;\n    }\n\n    case 'test_done': {\n      event.test.duration = (0, _utils.getTestDuration)(event.test);\n      event.test.status = 'done';\n      state.currentlyRunningTest = null;\n      break;\n    }\n\n    case 'test_start': {\n      state.currentlyRunningTest = event.test;\n      event.test.startedAt = jestNow();\n      event.test.invocations += 1;\n      break;\n    }\n\n    case 'test_fn_start': {\n      event.test.seenDone = false;\n      break;\n    }\n\n    case 'test_fn_failure': {\n      const {\n        error,\n        test: {asyncError}\n      } = event;\n      event.test.errors.push([error, asyncError]);\n      break;\n    }\n\n    case 'test_retry': {\n      event.test.errors = [];\n      break;\n    }\n\n    case 'run_start': {\n      state.hasStarted = true;\n      global[_types.TEST_TIMEOUT_SYMBOL] &&\n        (state.testTimeout = global[_types.TEST_TIMEOUT_SYMBOL]);\n      break;\n    }\n\n    case 'run_finish': {\n      break;\n    }\n\n    case 'setup': {\n      // Uncaught exception handlers should be defined on the parent process\n      // object. If defined on the VM's process object they just no op and let\n      // the parent process crash. It might make sense to return a `dispatch`\n      // function to the parent process and register handlers there instead, but\n      // i'm not sure if this is works. For now i just replicated whatever\n      // jasmine was doing -- dabramov\n      state.parentProcess = event.parentProcess;\n      (0, _utils.invariant)(state.parentProcess);\n      state.originalGlobalErrorHandlers = (0,\n      _globalErrorHandlers.injectGlobalErrorHandlers)(state.parentProcess);\n\n      if (event.testNamePattern) {\n        state.testNamePattern = new RegExp(event.testNamePattern, 'i');\n      }\n\n      break;\n    }\n\n    case 'teardown': {\n      (0, _utils.invariant)(state.originalGlobalErrorHandlers);\n      (0, _utils.invariant)(state.parentProcess);\n      (0, _globalErrorHandlers.restoreGlobalErrorHandlers)(\n        state.parentProcess,\n        state.originalGlobalErrorHandlers\n      );\n      break;\n    }\n\n    case 'error': {\n      // It's very likely for long-running async tests to throw errors. In this\n      // case we want to catch them and fail the current test. At the same time\n      // there's a possibility that one test sets a long timeout, that will\n      // eventually throw after this test finishes but during some other test\n      // execution, which will result in one test's error failing another test.\n      // In any way, it should be possible to track where the error was thrown\n      // from.\n      state.currentlyRunningTest\n        ? state.currentlyRunningTest.errors.push(event.error)\n        : state.unhandledErrors.push(event.error);\n      break;\n    }\n  }\n};\n\nvar _default = eventHandler;\nexports.default = _default;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}